<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of matRad_example1_phantom</title>
  <meta name="keywords" content="matRad_example1_phantom">
  <meta name="description" content="% Example: Generate your own phantom geometry">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- ../menu.html matRad --><!-- menu.html examples -->
<h1>matRad_example1_phantom
</h1>

<h2><a name="_name"></a>Purpose <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box">% Example: Generate your own phantom geometry</div>

<h2><a name="_synopsis"></a>Synopsis <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box">This is a script file. </div>

<h2><a name="_description"></a>Description <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment">% Example: Generate your own phantom geometry

 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

 Copyright 2018 the matRad development team. 
 
 This file is part of the matRad project. It is subject to the license 
 terms in the LICENSE file found in the top-level directory of this 
 distribution and at https://github.com/e0404/matRad/LICENSES.txt. No part 
 of the matRad project, including this file, may be copied, modified, 
 propagated, or distributed except according to the terms contained in the 
 LICENSE file.

 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>Cross-reference information <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-type:disc">
<li><a href="../../matRad/dicom/@matRad_DicomExporter/matRad_DicomExporter.html" class="code" title="">matRad_DicomExporter</a>	</li><li><a href="../../matRad/matRad_calcPhotonDose.html" class="code" title="function dij = matRad_calcPhotonDose(ct,stf,pln,cst,calcDoseDirect)">matRad_calcPhotonDose</a>	matRad photon dose calculation wrapper</li><li><a href="../../matRad/matRad_fluenceOptimization.html" class="code" title="function [resultGUI,optimizer] = matRad_fluenceOptimization(dij,cst,pln)">matRad_fluenceOptimization</a>	matRad inverse planning wrapper function</li><li><a href="../../matRad/matRad_generateStf.html" class="code" title="function stf = matRad_generateStf(ct,cst,pln,visMode)">matRad_generateStf</a>	matRad steering information generation</li><li><a href="../../matRad/matRad_getIsoCenter.html" class="code" title="function isoCenter = matRad_getIsoCenter(cst,ct,visBool)">matRad_getIsoCenter</a>	computes the isocenter [mm] as the joint center of gravity</li><li><a href="../../matRad/matRad_rc.html" class="code" title="">matRad_rc</a>	matRad rc script</li><li><a href="../../matRad/tools/matRad_plotSliceWrapper.html" class="code" title="function [hCMap,hDose,hCt,hContour,hIsoDose] = matRad_plotSliceWrapper(axesHandle,ct,cst,cubeIdx,dose,plane,slice,thresh,alpha,contourColorMap,doseColorMap,doseWindow,doseIsoLevels,voiSelection,colorBarLabel,boolPlotLegend,varargin)">matRad_plotSliceWrapper</a>	matRad tool function to directly plot a complete slice of a ct with dose</li></ul>
This function is called by:
<ul style="list-style-type:disc">
</ul>
<!-- crossreference -->



<h2><a name="_source"></a>Source code <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <span class="comment">%% Example: Generate your own phantom geometry</span>
0002 <span class="comment">%</span>
0003 <span class="comment">% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0004 <span class="comment">%</span>
0005 <span class="comment">% Copyright 2018 the matRad development team.</span>
0006 <span class="comment">%</span>
0007 <span class="comment">% This file is part of the matRad project. It is subject to the license</span>
0008 <span class="comment">% terms in the LICENSE file found in the top-level directory of this</span>
0009 <span class="comment">% distribution and at https://github.com/e0404/matRad/LICENSES.txt. No part</span>
0010 <span class="comment">% of the matRad project, including this file, may be copied, modified,</span>
0011 <span class="comment">% propagated, or distributed except according to the terms contained in the</span>
0012 <span class="comment">% LICENSE file.</span>
0013 <span class="comment">%</span>
0014 <span class="comment">% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0015 
0016 <span class="comment">%%</span>
0017 <span class="comment">% In this example we will show</span>
0018 <span class="comment">% (i) how to create arbitrary ct data (resolution, ct numbers)</span>
0019 <span class="comment">% (ii) how to create a cst structure containing the volume of interests of the phantom</span>
0020 <span class="comment">% (iii) generate a treatment plan for this phantom</span>
0021 
0022 <a href="../../matRad/matRad_rc.html" class="code" title="">matRad_rc</a>; <span class="comment">%If this throws an error, run it from the parent directory first to set the paths</span>
0023 
0024 <span class="comment">%% Create a CT image series</span>
0025 xDim = 200;
0026 yDim = 200;
0027 zDim = 50;
0028 
0029 ct.cubeDim      = [yDim xDim zDim]; <span class="comment">% second cube dimension represents the x-coordinate</span>
0030 ct.resolution.x = 2;
0031 ct.resolution.y = 2;
0032 ct.resolution.z = 3;
0033 ct.numOfCtScen  = 1;
0034  
0035 <span class="comment">% create an ct image series with zeros - it will be filled later</span>
0036 ct.cubeHU{1} = ones(ct.cubeDim) * -1000; <span class="comment">% assign HU of Air</span>
0037 
0038 <span class="comment">%% Create the VOI data for the phantom</span>
0039 <span class="comment">% Now we define structures a contour for the phantom and a target</span>
0040 
0041 ixOAR = 1;
0042 ixPTV = 2;
0043 
0044 <span class="comment">% define general VOI properties</span>
0045 cst{ixOAR,1} = 0;
0046 cst{ixOAR,2} = <span class="string">'contour'</span>;
0047 cst{ixOAR,3} = <span class="string">'OAR'</span>;
0048 
0049 cst{ixPTV,1} = 1;
0050 cst{ixPTV,2} = <span class="string">'target'</span>;
0051 cst{ixPTV,3} = <span class="string">'TARGET'</span>;
0052  
0053 <span class="comment">% define optimization parameter for both VOIs</span>
0054 cst{ixOAR,5}.TissueClass  = 1;
0055 cst{ixOAR,5}.alphaX       = 0.1000;
0056 cst{ixOAR,5}.betaX        = 0.0500;
0057 cst{ixOAR,5}.Priority     = 2;
0058 cst{ixOAR,5}.Visible      = 1;
0059 cst{ixOAR,5}.visibleColor = [0 0 0];
0060 
0061 <span class="comment">% define objective as struct for compatibility with GNU Octave I/O</span>
0062 cst{ixOAR,6}{1} = struct(DoseObjectives.matRad_SquaredOverdosing(10,30));
0063 
0064 cst{ixPTV,5}.TissueClass = 1;
0065 cst{ixPTV,5}.alphaX      = 0.1000;
0066 cst{ixPTV,5}.betaX       = 0.0500;
0067 cst{ixPTV,5}.Priority    = 1;
0068 cst{ixPTV,5}.Visible     = 1;
0069 cst{ixPTV,5}.visibleColor = [1 1 1];
0070 
0071 <span class="comment">% define objective as struct for compatibility with GNU Octave I/O</span>
0072 cst{ixPTV,6}{1} = struct(DoseObjectives.matRad_SquaredDeviation(800,60));
0073 
0074 <span class="comment">%% Lets create either a cubic or a spheric phantom</span>
0075 
0076 TYPE = <span class="string">'spheric'</span>;   <span class="comment">% either 'cubic' or 'spheric'</span>
0077 
0078 <span class="comment">% first the OAR</span>
0079 cubeHelper = zeros(ct.cubeDim);
0080 
0081 <span class="keyword">switch</span> TYPE
0082    
0083    <span class="keyword">case</span> {<span class="string">'cubic'</span>}
0084       
0085       xLowOAR  = round(xDim/2 - xDim/4);
0086       xHighOAR = round(xDim/2 + xDim/4);
0087       yLowOAR  = round(yDim/2 - yDim/4);
0088       yHighOAR = round(yDim/2 + yDim/4);
0089       zLowOAR  = round(zDim/2 - zDim/4);
0090       zHighOAR = round(zDim/2 + zDim/4);
0091       
0092       <span class="keyword">for</span> x = xLowOAR:1:xHighOAR
0093          <span class="keyword">for</span> y = yLowOAR:1:yHighOAR
0094             <span class="keyword">for</span> z = zLowOAR:1:zHighOAR
0095                cubeHelper(y,x,z) = 1;
0096             <span class="keyword">end</span>
0097          <span class="keyword">end</span>
0098       <span class="keyword">end</span>
0099       
0100    <span class="keyword">case</span> {<span class="string">'spheric'</span>}
0101       
0102       radiusOAR = xDim/4;
0103       
0104       <span class="keyword">for</span> x = 1:xDim
0105          <span class="keyword">for</span> y = 1:yDim
0106             <span class="keyword">for</span> z = 1:zDim
0107                currPost = [y x z] - round([ct.cubeDim./2]);
0108                <span class="keyword">if</span>  sqrt(sum(currPost.^2)) &lt; radiusOAR
0109                   cubeHelper(y,x,z) = 1;
0110                <span class="keyword">end</span>
0111             <span class="keyword">end</span>
0112          <span class="keyword">end</span>
0113       <span class="keyword">end</span>
0114       
0115 <span class="keyword">end</span>
0116 
0117 <span class="comment">% extract the voxel indices and save it in the cst</span>
0118 cst{ixOAR,4}{1} = find(cubeHelper);
0119 
0120 
0121 <span class="comment">% second the PTV</span>
0122 cubeHelper = zeros(ct.cubeDim);
0123 
0124 <span class="keyword">switch</span> TYPE
0125    
0126    <span class="keyword">case</span> {<span class="string">'cubic'</span>}
0127       
0128       xLowPTV  = round(xDim/2 - xDim/8);
0129       xHighPTV = round(xDim/2 + xDim/8);
0130       yLowPTV  = round(yDim/2 - yDim/8);
0131       yHighPTV = round(yDim/2 + yDim/8);
0132       zLowPTV  = round(zDim/2 - zDim/8);
0133       zHighPTV = round(zDim/2 + zDim/8);
0134       
0135       cubeHelper = zeros(ct.cubeDim);
0136       
0137       <span class="keyword">for</span> x = xLowPTV:1:xHighPTV
0138          <span class="keyword">for</span> y = yLowPTV:1:yHighPTV
0139             <span class="keyword">for</span> z = zLowPTV:1:zHighPTV
0140                cubeHelper(y,x,z) = 1;
0141             <span class="keyword">end</span>
0142          <span class="keyword">end</span>
0143       <span class="keyword">end</span>
0144       
0145    <span class="keyword">case</span> {<span class="string">'spheric'</span>}
0146       
0147       radiusPTV = xDim/12;
0148       
0149       <span class="keyword">for</span> x = 1:xDim
0150          <span class="keyword">for</span> y = 1:yDim
0151             <span class="keyword">for</span> z = 1:zDim
0152                currPost = [x y z] - round([ct.cubeDim./2]);
0153                <span class="keyword">if</span>  sqrt(sum(currPost.^2)) &lt; radiusPTV
0154                   cubeHelper(y,x,z) = 1;
0155                <span class="keyword">end</span>
0156             <span class="keyword">end</span>
0157          <span class="keyword">end</span>
0158       <span class="keyword">end</span>
0159       
0160 <span class="keyword">end</span>
0161 
0162 
0163 
0164 <span class="comment">% extract the voxel indices and save it in the cst</span>
0165 cst{ixPTV,4}{1} = find(cubeHelper);
0166 
0167 
0168 <span class="comment">% now we have ct data and cst data for a new phantom</span>
0169 display(ct);
0170 display(cst);
0171 
0172 <span class="comment">%% Assign relative electron densities</span>
0173 vIxOAR = cst{ixOAR,4}{1};
0174 vIxPTV = cst{ixPTV,4}{1};
0175 
0176 ct.cubeHU{1}(vIxOAR) = 0;
0177 ct.cubeHU{1}(vIxPTV) = 0;
0178 
0179 <span class="comment">%% Treatment Plan</span>
0180 <span class="comment">% The next step is to define your treatment plan labeled as 'pln'. This</span>
0181 <span class="comment">% structure requires input from the treatment planner and defines the most</span>
0182 <span class="comment">% important cornerstones of your treatment plan.</span>
0183 <span class="comment">%%</span>
0184 <span class="comment">% First of all, we need to define what kind of radiation modality we would</span>
0185 <span class="comment">% like to use. Possible values are photons, protons or carbon. In this</span>
0186 <span class="comment">% example we would like to use photons for treatment planning. Next, we</span>
0187 <span class="comment">% need to define a treatment machine to correctly load the corresponding</span>
0188 <span class="comment">% base data. matRad features generic base data in the file</span>
0189 <span class="comment">% 'photons_Generic.mat'; consequently the machine has to be set to 'Generic'</span>
0190 pln.radiationMode = <span class="string">'photons'</span>;            
0191 pln.machine       = <span class="string">'Generic'</span>;
0192 
0193 <span class="comment">%%</span>
0194 <span class="comment">% Define the flavor of biological optimization for treatment planning along</span>
0195 <span class="comment">% with the quantity that should be used for optimization. Possible values</span>
0196 <span class="comment">% are (none: physical dose based optimization; const_RBExD: constant RBE of 1.1;</span>
0197 <span class="comment">% LEMIV_effect: effect-based optimization; LEMIV_RBExD: optimization of</span>
0198 <span class="comment">% RBE-weighted dose. As we use photons, we select 'none' as we want to optimize the</span>
0199 <span class="comment">% physical dose.</span>
0200 pln.propOpt.bioOptimization = <span class="string">'none'</span>;                                              
0201 
0202 <span class="comment">%%</span>
0203 <span class="comment">% The remaining plan parameters are set like in the previous example files</span>
0204 pln.numOfFractions        = 30;
0205 pln.propStf.gantryAngles  = [0 45];
0206 pln.propStf.couchAngles   = [0 0];
0207 pln.propStf.bixelWidth    = 5;
0208 pln.propStf.numOfBeams    = numel(pln.propStf.gantryAngles);
0209 pln.propStf.isoCenter     = ones(pln.propStf.numOfBeams,1) * <a href="../../matRad/matRad_getIsoCenter.html" class="code" title="function isoCenter = matRad_getIsoCenter(cst,ct,visBool)">matRad_getIsoCenter</a>(cst,ct,0);
0210 pln.propOpt.runDAO        = 0;
0211 pln.propOpt.runSequencing = 0;
0212 
0213 <span class="comment">% dose calculation settings</span>
0214 pln.propDoseCalc.doseGrid.resolution.x = 3; <span class="comment">% [mm]</span>
0215 pln.propDoseCalc.doseGrid.resolution.y = 3; <span class="comment">% [mm]</span>
0216 pln.propDoseCalc.doseGrid.resolution.z = 3; <span class="comment">% [mm]</span>
0217 
0218 <span class="comment">%% Generate Beam Geometry STF</span>
0219 stf = <a href="../../matRad/matRad_generateStf.html" class="code" title="function stf = matRad_generateStf(ct,cst,pln,visMode)">matRad_generateStf</a>(ct,cst,pln);
0220 
0221 <span class="comment">%% Dose Calculation</span>
0222 dij = <a href="../../matRad/matRad_calcPhotonDose.html" class="code" title="function dij = matRad_calcPhotonDose(ct,stf,pln,cst,calcDoseDirect)">matRad_calcPhotonDose</a>(ct,stf,pln,cst);
0223 
0224 <span class="comment">%% Inverse Optimization for intensity-modulated photon therapy</span>
0225 <span class="comment">% The goal of the fluence optimization is to find a set of bixel/spot</span>
0226 <span class="comment">% weights which yield the best possible dose distribution according to the</span>
0227 <span class="comment">% clinical objectives and constraints underlying the radiation treatment.</span>
0228 resultGUI = <a href="../../matRad/matRad_fluenceOptimization.html" class="code" title="function [resultGUI,optimizer] = matRad_fluenceOptimization(dij,cst,pln)">matRad_fluenceOptimization</a>(dij,cst,pln);
0229 
0230 <span class="comment">%% Plot the resulting dose slice</span>
0231 plane      = 3;
0232 slice      = round(pln.propStf.isoCenter(1,3)./ct.resolution.z);
0233 doseWindow = [0 max([resultGUI.physicalDose(:)])];
0234 
0235 figure,title(<span class="string">'phantom plan'</span>)
0236 <a href="../../matRad/tools/matRad_plotSliceWrapper.html" class="code" title="function [hCMap,hDose,hCt,hContour,hIsoDose] = matRad_plotSliceWrapper(axesHandle,ct,cst,cubeIdx,dose,plane,slice,thresh,alpha,contourColorMap,doseColorMap,doseWindow,doseIsoLevels,voiSelection,colorBarLabel,boolPlotLegend,varargin)">matRad_plotSliceWrapper</a>(gca,ct,cst,1,resultGUI.physicalDose,plane,slice,[],[],colorcube,[],doseWindow,[]);
0237 
0238 <span class="comment">%%</span>
0239 <span class="comment">% We export the the created phantom &amp; dose as dicom. This is handled by the</span>
0240 <span class="comment">% class matRad_DicomExporter. When no arguments are given, the exporter searches</span>
0241 <span class="comment">% the workspace itself for matRad-structures. The output directory can be set by</span>
0242 <span class="comment">% the property dicomDir. While the different DICOM datasets (ct, RTStruct, etc)</span>
0243 <span class="comment">% can be exported individually, we call the wrapper to do all possible exports.</span>
0244 dcmExport = <a href="../../matRad/dicom/@matRad_DicomExporter/matRad_DicomExporter.html" class="code" title="">matRad_DicomExporter</a>();
0245 dcmExport.dicomDir = [pwd filesep <span class="string">'dicomExport'</span>];
0246 dcmExport.matRad_exportDicom();
0247</pre></div>
<hr><address><a href="https://e0404.github.io/matRad/" target="_parent"><img src="https://camo.githubusercontent.com/0a593ef6a04757c975b9f4634f6731ea0b019bbd/68747470733a2f2f7261776769742e636f6d2f77696b692f65303430342f6d61745261642f696d616765732f6d61747261645f626c616e6b2e737667" height="12px"/></a> | Generated by  <a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>